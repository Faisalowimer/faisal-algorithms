"use client"

import { useEffect, useState } from "react";

export type Algorithms =
    | "Linear Search" | "Binary Search"
    | "Depth-First Search" | "Breadth-First Search"
    | "Bubble Sort" | "Selection Sort"
    | "Insertion Sort" | "Merge Sort"
    | "Quick Sort" | "Dijkstra's Algorithm" | ""
interface AlgorithmVisualizerProps {
    algorithm: string // selected algo name
    steps: any[] // array of steps generated by selected algo
    target?: number // target value
    renderStep: (step: any, currentStepIndex: number, totalSteps: number, allStacks?: any[]) => JSX.Element // frunction to render each step
}

export const algorithmInfo: Record<string, {
    description: string,
    timeComplexity?: string,
    spaceComplexity?: string,
}> = {
    "Linear Search": {
        description: `Linear Search scans each element of the array 
        one by one until the target value is found. It works for 
        both sorted and unsorted arrays.`,
    },
    "Binary Search": {
        description: `Binary Search works by repeatedly dividing a 
        sorted array in half and comparing the middle element with
        the target value. If the target is smaller, the left half 
        is considered; if larger, the right half is considered.`,
    },
    "Depth-First Search": {
        description: `Depth-First Search (DFS) explores as far as 
        possible along a branch before backtracking. It's commonly 
        used for tree and graph traversals.`,
    },
    "Breadth-First Search": {
        description: `Breadth-First Search (BFS) explores all the neighbor 
        nodes at the present depth before moving on to nodes at the next depth 
        level. It's often used for shortest path problems in unweighted graphs.`,
    },
    "Bubble Sort": {
        description: `Bubble Sort compares adjacent elements in an array and 
        swaps them if they are in the wrong order. It repeats this process 
        until the array is sorted.`,
    },
    "Selection Sort": {
        description: `Selection Sort repeatedly finds the minimum element from 
        the unsorted part of the array and swaps it with the first unsorted element, 
        moving the boundary of the sorted part.`,
    },
    "Insertion Sort": {
        description: `Insertion Sort builds the sorted array one element at a time 
        by picking elements and inserting them into their correct position in the 
        already sorted part.`,
    },
    "Merge Sort": {
        description: `Merge Sort divides the array into two halves, 
        recursively sorts each half, and then merges the two halves 
        back together in sorted order.`,
    },
    "Quick Sort": {
        description: `Quick Sort picks a pivot element, partitions the array around the pivot, 
        and recursively sorts the partitions. It works efficiently in average cases but can 
        degrade in performance in certain cases.`,
    },
    "Dijkstra's Algorithm": {
        description: `Dijkstra's Algorithm is used to find the shortest path from a starting 
            node to all other nodes in a weighted graph with non-negative weights. It uses a 
            priority queue to explore the nearest nodes first.`,
    }
}

const AlgorithmVisualizer: React.FC<AlgorithmVisualizerProps> = ({
    algorithm,
    steps,
    target,
    renderStep,
}) => {
    const [currentStepIndex, setCurrentStepIndex] = useState(0)
    const [isPlaying, setIsPlaying] = useState(false)

    // go to next step
    const nextStep = () => {
        if (currentStepIndex < steps.length - 1) {
            setCurrentStepIndex(currentStepIndex + 1)
        } else {
            setIsPlaying(false) // stop playing of we reach last step 

            setTimeout(() => {
                setCurrentStepIndex(0) // reset to initial state
            }, 5000)
        }
    }

    // go to previous step
    const prevStep = () => {
        if (currentStepIndex > 0) {
            setCurrentStepIndex(currentStepIndex - 1)
        }
    }

    // restart visualization
    const restart = () => {
        setCurrentStepIndex(0)
        setIsPlaying(false)
    }

    // play visualization
    useEffect(() => {
        let interval: NodeJS.Timeout | null = null

        if (isPlaying) {
            interval = setInterval(() => {
                nextStep()
            }, 1000)

            // stop interval when user pauses or reaches last step
            return () => {
                if (interval) clearInterval(interval)
            }
        }
    }, [isPlaying, nextStep, currentStepIndex, steps.length])

    const selectedAlgo = algorithmInfo[algorithm]

    return (
        <div className=" flex flex-col items-center p-4 bg-gray-100 rounded-lg shadow-lg">
            <h2 className="text-2xl font-bold text-gray-800 mb-4">
                Visualization for {algorithm}
            </h2>
            <div>
                {selectedAlgo
                    ? (
                        <div className="space-y-2 mb-4">
                            <p className="font-semibold text-gray-700">
                                Description:
                            </p>
                            <p className="text-gray-600">
                                {selectedAlgo.description}
                            </p>
                            {algorithmInfo.timeComplexity && (
                                <>
                                    <p className="font-semibold text-gray-700">
                                        Time Complexity:
                                    </p>
                                    <p className="text-gray-600">
                                        {selectedAlgo.timeComplexity}
                                    </p>
                                </>
                            )}
                            {algorithmInfo.spaceComplexity && (
                                <>
                                    <p className="font-semibold text-gray-700">
                                        Space Complexity:
                                    </p>
                                    <p className="text-gray-600">
                                        {selectedAlgo.spaceComplexity}
                                    </p>
                                </>
                            )}
                        </div>
                    ) : (
                        <p className="text-gray-500">
                            Select an algorithm to visualize.
                        </p>
                    )
                }
            </div>
            {(algorithm === "Linear Search" || algorithm === "Binary Search") && (
                <p className="text-xl font-semibold text-gray-700 mb-4">
                    Target: {target}
                </p>
            )}
            <div className="mb-8">
                {renderStep(steps[currentStepIndex], currentStepIndex, steps.length)}
            </div>
            <div className="flex space-x-4">
                <button
                    onClick={() => setIsPlaying(!isPlaying)}
                    className={`px-4 py-2 text-white rounded-md ${isPlaying ? "bg-red-500" : "bg-blue-500"}`}
                >
                    {isPlaying ? "Pause" : "Play"}
                </button>
                <button
                    onClick={nextStep}
                    disabled={currentStepIndex === steps.length - 1}
                    className="px-4 py-2 bg-green-500 text-white rounded-md"
                >
                    Next
                </button>
                <button
                    onClick={prevStep}
                    disabled={currentStepIndex === 0}
                    className="px-4 py-2 bg-gray-500 text-white rounded-md"
                >
                    Previous
                </button>
                <button
                    onClick={restart}
                    className="px-4 py-2 bg-yellow-500 text-white rounded-md"
                >
                    Restart
                </button>
            </div>
        </div>
    )
}

export default AlgorithmVisualizer